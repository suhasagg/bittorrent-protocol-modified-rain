package subs

import (
	"encoding/json"
	"fmt"
	"sync"

	"github.com/bittorrent/utils"
	"github.com/bittorrentaccessories/plugin/types"
	"github.com/gogo/protobuf/proto"
	"github.com/phonkee/go-pubsub"
)

type LegacybittorrentSubscriptionSet struct {
	pubsub.ResetHub
	clients map[string]pubsub.Subscriber
	callers map[string][]string
	sync.RWMutex
}

func NewLegacybittorrentSubscriptionSet() *LegacybittorrentSubscriptionSet {
	s := &LegacybittorrentSubscriptionSet{
		ResetHub: NewLegacybittorrentResetHub(),
		// maps ID to subscriber
		clients: make(map[string]pubsub.Subscriber),
		// maps remote socket address to list of subscriber IDs
		callers: make(map[string][]string),
	}
	return s

}

func (s *LegacybittorrentSubscriptionSet) For(caller string) (pubsub.Subscriber, string) {
	sub := s.Subscribe("")
	id := utils.GetId()
	s.Lock()
	defer s.Unlock()

	s.clients[id] = sub
	if bittorrentSub, ok := sub.(*bittorrentSubscriber); ok {
		bittorrentSub.id = id
	}

	s.callers[caller] = append(s.callers[caller], id)

	return s.clients[id], id
}

func (s *LegacyBittorrentSubscriptionSet) AddSubscription(id, method, topic string) error {
	var topics string
	var err error
	switch method {
	//a)
	//1)Torrent session (Download session, upload session)
	//2)System parameters for download session, upload session
	//Torrent Session Hub

	//b)
	//File Metadata Hub
	//Synchronisation of file metadata of a peers across peer set
	//File category centric

	//c)
	//For peer priority Algorithm

	//System Property Hub of Peer
	//System information of peers synchronised across other peers set
	//Third party databases to get device information

	//d)
	//Properties which are determined based on IP Addresses using Maxmind Databases
	//ISP provider, Organisation

	//e)
	//Download/Upload speed for a peer, (Parameter is available from peer benchmark data store)
	//Download/upload graph of peer

	//f)
	//All these data points derived from p2p system can be used to train ML model (which can be used for certain category of predictions)
	//Importance of ML model - Category of Predictions
	//Data points -
	//1)Hour of the day
	//2)Average Download Speed
        //3)Average Upload Speed
	//4)IP Address derived properties using Maxmind - ISP, City, zip code, Lat long, 
	//5)Hardware Properties of the peer - OS, Device Type, Detailed Machine Information
	//6)Requests made to the trackers (udp, http, secure web socket)
	//7)File category
	//a)Goal to derive most optimum peer (Least Download latencies) according to the time of day from a peer lat long
	//b)trackers to use according to time of the day from a peer lat long
	//c)Dashboard for visualising (data points) logs generated by p2p system 

        case TorrentSessionData:
		topics = topic
	case FileMetadata:
		topics = topic
	case SystemProperty:
		topics = topic
	case IPAddressProperties:
		topics = topic
	case DataTransferProperties:
		topics = topic
        case TrackerDataPoints:
		topics = topic		
	default:
		err = fmt.Errorf("unrecognised method %s", method)
	}
	if err != nil {
		return err
	}
	s.Lock()
	sub, exists := s.clients[id]
	if exists {
		sub.Subscribe(topics)
	} else {
		err = fmt.Errorf("Subscription %s not found", id)
	}
	s.Unlock()

	return err
}

func (s *LegacybittorrentSubscriptionSet) Purge(caller string) {
	var subsToClose []pubsub.Subscriber
	s.Lock()
	if ids, found := s.callers[caller]; found {
		for _, id := range ids {
			if c, ok := s.clients[id]; ok { 
				subsToClose = append(subsToClose, c)
				delete(s.clients, id)
			}
		}
		delete(s.callers, caller)
	}
	s.Unlock()
	for _, sub := range subsToClose {
		s.CloseSubscriber(sub)
	}

}

func (s *LegacybittorrentSubscriptionSet) Remove(id string) (err error) {
	s.Lock()
	c, ok := s.clients[id]
	s.Unlock()
	if !ok {
		err = fmt.Errorf("Subscription not found")
	} else {
		s.CloseSubscriber(c)
		s.Lock()
		delete(s.clients, id)
		s.Unlock()
	}

	return err
}


